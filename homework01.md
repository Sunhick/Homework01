## Homework 1

1. Define the term essential difficulties as it is used by Brooks. Provide background and context with your answer and at least one example of an essential difficulty.
***

2. Define the term accidental difficulties as it is used by Brooks. Provide background and context with your answer and at least one example of an accidental difficulty.
***

3. List and briefly describe the four essential difficulties of developing software systems that Brooks identifies. Provide additional examples of each type of the four essential difficulties.
    
     The four essential difficulties that are described by Brooks are:

     1. Complexity – According to Brooks, Software entities are complex. He explains that no two parts are alike and there are contrasts with materials in other domain. According to him large software systems have a huge number of states that is the software has a higher order of magnitude more states than the computer hardware and also he points out that as the size of the system increases there is an exponential increase in the number and types of parts. It is usually not possible to abstract away the complexity of the application domain.
 
     Let us consider some domains such as the air traffic control, international banking or avionics software. Although these domains are complex from within, they can be only visualized when the designers attempt to model the domain. The complexity can also arise from various links between different artefacts such as specifications, documentation, code, test cases and many more.
 
     Brooks also specifies certain problems that are caused due to complexity. Some of the most common issues are difficult team communication, Delays, flaws in the products, unanticipated difficulties and many more.
 
     2. Conformity – Brooks explains that a lot of software engineers who face complexity which is very arbitrary. He gives an example of a system that supports an existing business process when a new VP arrives. He explains the situation by considering a condition where the VP decides to change the business process to prove his hold on the company. The employees, no matter what their opinion is, should conform to the new arbitrary changes which might prove to be complex.
 
     He explains some other instances of conformity such as adapting to a pre existing environment which involves integrating ourselves with the legal system, being ready to change the software depending on the changes in the environment. Brooks stresses on the fact that “It is almost impossible to plan for an arbitrary change”.
 
     3. Changeability – Brooks states that the software is constantly evolving. In terms of the hardware he explains that once they are manufactured they cannot be changed, but change can happen in the later models like in automobiles, but there is a tradeoff that is required between change and cost in case of hardware components.
    
     Brooks also explains that there is a greater pressure for the software to change. He points out that a change in the software means a change in either one or more of its functionality and hence making it more malleable. He also emphasizes that certain clients do not understand the difficulty of changing the functionality of a software and the rework required in it.
 
     4. Invisibility -  Brooks explains that the software is invisible and non visualizable. He explains that it is very difficult to create a software blueprint to help the developers. He explains this difficulty by taking the example of UML diagrams, the different types of diagrams they have and the complexity of using them in all together.  
***

4. Define what Brooks means by a silver bullet and reconstruct his argument as to why he believes there is no silver bullet for software engineering.

   As per Brooks _"**Silver bullet**"_ means a standard process/procedure (like a _Golden hammer_) to address the missed project schedules, over budgets, buggy software etc. Something that can make the cost of producing software as low as the cost of manufacturing hardware. There is no single development in either software technology or management process that will guarantee at least order of one magnitude improvement in productivity, reliability, complexity. 

   Although it sounds appealing to look for silver bullet - none exists due to the very nature of software process. Firstly the software development progress is very slow as compared to the computer hardware progress. 

   As per Moore's law - 
   >"The number of transistors in a dense integrated circuit doubles approximately every two years.".

   This means that the hardware is progressing by two-folds every two years.

   secondly, the difficulties inherent in the software technology(essence) and those that attend its production ubt that are not inherent(accidents). Essential difficulties include complexity, conformity,  changeability and Invisibility. Accidental difficulties include high-level languages, time-sharing, and unified programming environments.
***

5. In lecture, software engineering's relationship to computer science was described by analogy by discussing the differences between a chemist (chemistry) and a chemical engineer (chemical engineering). Define software engineering and its relationship to computer science; make use of the chemist vs. chemical engineer analogy when answering this question.
***

6. In lecture, we discussed the importance of the following concepts to software engineers: abstractions, conversations, specification, translation, and iteration. Define each of these concepts as they are related to software engineering and discuss their importance.
***
